<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/avatar.png"/>
	<link rel="shortcut icon" href="/img/avatar.png">
	
			    <title>
    wuzhenren's blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/sunset.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src=""></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo"></a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Spring-Boot/">Spring Boot</a></li><li><a class="category-link" href="/categories/Spring-Boot/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/">工作日志</a></li><li><a class="category-link" href="/categories/leetcode/">leetcode</a></li><li><a class="category-link" href="/categories/ustc/">ustc</a></li><li><a class="category-link" href="/categories/ustc/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/">个人生活</a></li><li><a class="category-link" href="/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/">个人生活</a></li><li><a class="category-link" href="/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/">工作日志</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/motto/" title="motto">
		                motto
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/wzr1005" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="zhihu" href="https://www.zhihu.com/people/wu-zhen-ren" target="_blank" rel="noopener">
                            <i class="icon fa fa-zhihu"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://tva1.sinaimg.cn/large/008i3skNgy1gu22eea144j61900u0dtj02.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >9月2日</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p>@CacheAble没有写入缓存，是因为Cachemanager的名称和redisconfig的对应有问题，有可能有重名的方法名</p>
<p><code>Map&lt;String, String&gt; map = Maps.newHashMap();</code>，第一次接触到这种写法，这是引用了谷歌提供的guava包，依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>17.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>按照平常我们的习惯，在创建Map时，一般都会使用<code>new HashMap&lt;K, V&gt;()</code>，怀着好奇的心态，便看了一下源码，原来这个方法也是返回的一个HashMap，两则是一模一样的，只是这样写比较简洁而已。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function">HashMap&lt;K, V&gt; <span class="title">newHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K, V&gt;();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>当一个接口有2个不同实现时,使用@Autowired注解时会报org.springframework.beans.factory.NoUniqueBeanDefinitionException异常信息</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化就是一种用来处理对象流的机制，</p>
<p>所谓对象流也就是将对象的内容进行流化,将数据分解成字节流，以便存储在文件中或在网络上传输。</p>
<h4 id="那么什么时候进行序列化呢"><a href="#那么什么时候进行序列化呢" class="headerlink" title="那么什么时候进行序列化呢"></a>那么什么时候进行序列化呢</h4><p>因为要将流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。</p>
<p>序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable<strong>只是为了标注该对象是可被序列化的</strong>，然后使用一个输出流(如：FileOutputStream)来</p>
<p><strong>构造一个ObjectOutputStream(对象流)对象，</strong></p>
<p>接着，使用ObjectOutputStream对象的writeObject(Object obj)方法</p>
<p>**就可以将参数为obj的对象写出(即保存其状态)**要恢复的话则用输入流;</p>
<p>序列化分为两大部分：序列化和反序列化。序列化是这个过程的第一部分，将数据分解成字节流，以便存储在文件中或在网络上传输。</p>
<p><strong>反序列化就是打开字节流并重构对象。</strong></p>
<p>对象序列化不仅要将基本数据类型转换成字节表示，有时还要恢复数据。</p>
<p>序列化的什么特点：</p>
<p>如果某个类能够被序列化，其子类也可以被序列化。声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态， <strong>transient代表对象的临时数据</strong>。</p>
<p>什么时候使用序列化：<br>　　一：对象序列化可以实现分布式对象。主要应用例如：RMI要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。<br>　　二：java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的”深复制”，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。</p>
<p>序列化:序列化是将对象转换为容易传输的格式的过程。例如，可以序列化一个对象，然后使用 HTTP 通过 Internet 在客户端和服务器之间传输该对象。在另一端，反序列化将从该流重新构造对象。<br>　　是对象永久化的一种机制。<br>　　确切的说应该是对象的序列化，一般程序在运行时，产生对象，这些对象随着程序的停止运行而消失，但<strong>如果我们想把某些对象（因为是对象，所以有各自不同的特性）保存下来</strong>(想想保存在哪里，就是项目文件夹呗)，在程序终止运行后，这些对象仍然存在，可以在程序再次运行时读取这些对象的值，或者在其他程序中利用这些保存下来的对象。<strong>这种情况下就要用到对象的序列化。</strong></p>
<p><strong>只有序列化的对象才可以存储在存储设备上。</strong>为了对象的序列化而需要继承的接口也只是一个象征性的接口而已,也就是说继承这个接口说明这个对象可以被序列化了，没有其他的目的。</p>
<p>也就是说继承这个接口(implement Serializable)说明这个对象可以被序列化了，<strong>没有其他的目的</strong>。</p>
<p>之所以需要对象序列化，是因为有时候对象需要在网络上传输，<strong>传输的时候需要这种序列化处理</strong></p>
<p>从服务器硬盘上把序列化的对象取出，然后通过<strong>网络传到客户端</strong>，</p>
<p>再由客户端把序列化的对象读入内存，执行相应的处理。</p>
<hr>
<p>对象序列化是java的一个特征，通过该特征可以将对象写作一组字节码，当在其他位置读到这些字节码时，可以依此创建一个新的对象，而且新对象的状态与原对象完全相同。</p>
<p>为了实现对象序列化，要求必须能够访问类的私有变量，从而保证对象状态能够正确的得以保存和恢复。</p>
<p>相应的，对象序列化API能够在对象重建时，将这些值还原给私有的数据成员。</p>
<h4 id="这是对java语言访问权限的挑战。"><a href="#这是对java语言访问权限的挑战。" class="headerlink" title="这是对java语言访问权限的挑战。"></a>这是对java语言访问权限的挑战。</h4><h3 id="所以序列化通常用在服务器客户端的对象交换上面，另外就是在本机的存储。"><a href="#所以序列化通常用在服务器客户端的对象交换上面，另外就是在本机的存储。" class="headerlink" title="所以序列化通常用在服务器客户端的对象交换上面，另外就是在本机的存储。"></a>所以序列化通常用在服务器客户端的对象交换上面，另外就是在本机的存储。</h3><hr>
<p><strong>MySQL 会为每个线程分配固定大小的 sort buffer 用作排序</strong>。</p>
<p>sort buffer 是具有逻辑概念的内存区域，大小由</p>
<p>sort_buffer_size 参数控制，默认为 256 kb。</p>
<p>由于 sort buffer 大小固定，而 data(待排序的数据量)并不固定，所以根据 sort buffer 与 data(待排序数据量)的大小差值，可分为内部排序和外部排序：</p>
<p>data &lt;= sort buffer：即 sort buffer 够用，这时候 MySQL 只需要在内存中进行排序即可。内部排序使用的是<strong>快速排序</strong></p>
<p>data &gt; sort buffer：这时候 sort buffer 不够用，MySQL 需要借助外部“容器”(通常是文件)进行排序。通常会将待排序数据分成多个“小文件”，对各个“小文件”进行排序，再汇总成一个有序的“大文件”。<strong>外部排序使用的是归并排序</strong></p>
<p>如何验证当前执行的排序语句使用的是<strong>内部排序</strong>还是<strong>外部排序</strong>？</p>
<p>可以通过</p>
<p><strong>EXPLAIN 命令</strong>来查看，如果在分析结果中的</p>
<p>Extra <strong>字段里包含</strong></p>
<p><strong>Using filesort</strong> 字眼，说明执行了外部排序操作。</p>
<p>当查询条件本身有索引可用的话，全字段排序的排序过程都在 sort buffer(内存)进行，<strong>回表次数为符合条件的数据个数。</strong></p>
<p>当然，如果我们建立的是 <strong>city</strong>、<strong>nick_name</strong>、age、phone 的联合索引，还可以实现“索引覆盖”，即在一棵索引树上取得全部所需数据，减少回表(随机读)次数。</p>
<p>不过针对每个查询或排序语句建立联合索引，会导致索引过多，大大降低写入更新数据的速度，以及大大提升数据所需要的存储空间。</p>
<p>生产上对索引的建立修改需要格外谨慎。</p>
<hr>
<h4 id="rowId-排序全过程："><a href="#rowId-排序全过程：" class="headerlink" title="rowId 排序全过程："></a>rowId 排序全过程：</h4><p>从 <strong>city 索引</strong>树上找到第一条值为深圳的数据，</p>
<p>取得 id 之后回表(回到主键索引)<strong>取得 nick_name</strong> 这个与排序相关的字段</p>
<p><strong>和主键 id 一起放入 sort buffer</strong></p>
<p>从 city 索引树取下一条值为深圳的数据，</p>
<p>`</p>
<p>`</p>
<p>`</p>
<p>所有 city = 深圳 的数据都在 sort buffer 了,(<strong>sort buffer</strong> 里面的数据<strong>包含两个字段</strong>： id 和 nick_name)</p>
<p>对 nick_name 执行快速排序利用排序好的数据</p>
<p>使用主键 id 再次回表取其他字段，findById,将结果返回</p>
<h4 id="优先队列排序"><a href="#优先队列排序" class="headerlink" title="优先队列排序"></a>优先队列排序</h4><p>无论是使用全字段排序还是 rowId 排序，都不可避免了对所有符合</p>
<p>WHRER 条件的数据进行了排序。</p>
<p>设想一下，如果我们还搭配着</p>
<p>LIMIT 使用呢？</p>
<p>LIMIT 3 ，哪怕查出来的数据有 10W 行，我们也只需要前 3 行有序。</p>
<p><strong>为了得到前 3 行数据，而不得不将 10W 行数据载入内存，大大降低了 sort buffer 的利用率</strong>。</p>
<p>这时候你可能想到利用“最小堆”、“最大堆”来进行排序。</p>
<p>没错，这正是 MySQL 针对带有</p>
<p>LIMIT 的</p>
<p>ORDER BY 语句的优化：使用优先队列进行排序。</p>
<h4 id="优先队列进行排序的流程："><a href="#优先队列进行排序的流程：" class="headerlink" title="优先队列进行排序的流程："></a>优先队列进行排序的流程：</h4><p>在所有待排序的数据，取数量为</p>
<p>LIMIT (本例中为 3)的数据，构建一个堆不断的取下一行数据，更新堆节点当所有行的扫描完，得到最终的排序结果</p>
<p>如何选择?</p>
<p>现在我们知道有全字段排序和 rowId 排序，那么 MySQL 是如何在这两种排序方案中做选择呢？</p>
<p>由于 <strong>rowId 排序相对于全字段排序，不可避免的多了一次回表操作</strong>，<strong>回表操作意味着随机读</strong>(相对于整存整取的概念而言)，而随机 IO 是数据库中最昂贵的操作。</p>
<p>所以 MySQL 会在尽可能的情况下选择<strong>全字段</strong>排序。</p>
<p>那么什么情况下 MySQL 会选择 rowId 排序呢，是否有具体的值可以量度？</p>
<p>答案是有的，通过参数</p>
<p><strong>max_length_for_sort_data</strong> 可以控制用于排序的行数据最大长度，<strong>默认值为 1024 字节。</strong></p>
<p>当单行数据长度超过该值，MySQL 就会觉得如果还用<strong>全字段排序</strong>，会导致 <strong>sort buffer 容纳下的行数太少</strong>，</p>
<p>从而转为使用 rowId 排序。</p>
<p>临时表排序</p>
<p>通常对于一个执行较慢的排序语句，在使用</p>
<p>EXPLAIN 进行执行过程分析的时候除了能看到Using filesort 以外，</p>
<p>还能看到Using temporary，</p>
<p>代表在排序过程中使用到了临时表。</p>
<h4 id="内存临时表排序"><a href="#内存临时表排序" class="headerlink" title="内存临时表排序"></a>内存临时表排序</h4><p>MySQL 优先使用内存临时表。当 MySQL 使用内存临时表时，</p>
<h4 id="临时表存储引擎为-memory-。"><a href="#临时表存储引擎为-memory-。" class="headerlink" title="临时表存储引擎为 memory 。"></a>临时表存储引擎为 memory 。</h4><p>如果当前 MySQL 使用的是<strong>内存临时表的话</strong>，将会<strong>直接使用 rowId 排序，因为这时候所谓的“回表”只是在内存表中读数据，操作不涉及硬盘的随机 IO 读。</strong></p>
<p>如果系统中很多需要使用临时表的排序语句执行，而又不加以限制，全都使用临时表的话，内存很快就会被打满。</p>
<p>所以 MySQL 提供了</p>
<p><strong>tmp_table_size 参数</strong>限制了内存临时表的大小，默认值是 16M。</p>
<p>如果临时表大小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。</p>
<p>当使用磁盘临时表的时候，表储存引擎将不再是 memory，而是由</p>
<p>internal_tmp_disk_storage_engine 参数控制，默认为</p>
<p>InnoDB 。</p>
<p>这时候 MySQL 会根据单行大小是否超过</p>
<p>max_length_for_sort_data 决定采用全字段排序还是 rowId 排序。</p>
<h4 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h4><p>「<strong>全字段排序</strong>是指，只要与<strong>最终结果集有关的字段</strong>都会被放进 sort buffer，而不管该字段本身是否参与排序。」</p>
<p>rowId 排序</p>
<p>rowId 就是 MySQL 对每行数据的唯一标识符。</p>
<p>当数据表有主键时，rowId 就是表主键；当数据表没有主键或者主键被删除时，MySQL 会自动生成一个长度为 6 字节的 rowId 为作为 rowId。</p>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总结一下，MySQL 总是使用 「“最快”」 的排序方案：</p>
<p>当排序数据量不超过 <strong>sort buffer 容量</strong>时，MySQL 将会在内存使用<strong>快速排序算法</strong>进行排序(内部排序)；</p>
<p>当排序数据量超过 <strong>sort buffer 容量</strong>时，MySQL 将会借助临时磁盘文件使用<strong>归并排序算法进行排序</strong>(外部排序)</p>
<hr>
<p>在进行<strong>真正排序</strong>（理解什么是真正的排序时），MySQL 又会根据数据单行长度是否超过</p>
<p>max_length_for_sort_data而决定使用 rowId 排序还是全字段排序</p>
<p><strong>优先选择全字段排序，以减少回表次数</strong></p>
<p>当需要借助临时表的时候，会使用 rowId 排序方式；</p>
<p>当<strong>内存临时表大小超过</strong></p>
<p><strong>tmp_table_size</strong> 限制时，则需要将内存临时表转换为磁盘临时表</p>
<p>这时候由于回表意味着随机读，所以会搭配全字段排序方式</p>
<hr>
<h3 id="1、Redis"><a href="#1、Redis" class="headerlink" title="1、Redis"></a>1、Redis</h3><p>redis是一款开源的Key-Value数据库，<br>运行在内存中，由C语言编写。企业开发通常采用Redis来实现缓存。<br>同类的产品还有memcache 、memcached 等。</p>
<h3 id="2、Jedis"><a href="#2、Jedis" class="headerlink" title="2、Jedis"></a>2、Jedis</h3><p>Jedis是Redis官方推出的一款面向Java的客户端，提供了很多接口供Java语言调用。可以在Redis官网下载，当然还有一些开源爱好者提供的客户端，如Jredis、SRP等等，推荐使用Jedis。</p>
<h3 id="3、Spring-Data-Redis"><a href="#3、Spring-Data-Redis" class="headerlink" title="3、Spring Data Redis"></a>3、Spring Data Redis</h3><p>Spring-data-redis是spring大家族的一部分，提供了在srping应用中通过简单的配置访问redis服务，对reids底层开发包(Jedis, JRedis, and RJC)进行了高度封装，</p>
<p>RedisTemplate提供了redis各种操作、异常处理及序列化，支持发布订阅，并对spring 3.1 cache进行了实现。<br><strong>spring-data-redis针对jedis提供了如下功能：</strong></p>
<ol>
<li>连接池自动管理，提供了一个高度封装的“RedisTemplate”类</li>
<li>针对jedis客户端中大量api进行了归类封装,将同一类型操作封装为operation接口<ul>
<li>ValueOperations：简单K-V操作</li>
<li>SetOperations：set类型数据操作</li>
<li>ZSetOperations：zset类型数据操作</li>
<li>HashOperations：针对map类型的数据操作</li>
<li>ListOperations：针对list类型的数据操作</li>
</ul>
</li>
<li>提供了对key的“bound”(绑定)便捷化操作API，可以通过bound封装指定的key，然后进行一系列的操作而无须“显式”的再次指定Key，即BoundKeyOperations：</li>
<li>将事务操作封装，有容器控制。</li>
<li>针对数据的“序列化/反序列化”，提供了多种可选择策略(RedisSerializer)</li>
</ol>
<h3 id="Redis妙用–存储用户token"><a href="#Redis妙用–存储用户token" class="headerlink" title="Redis妙用–存储用户token"></a>Redis妙用–存储用户token</h3><p> 在设计类似电商的系统时，一个常见的需求是每个页面都需要携带登录用户信息。</p>
<p>常见的解决方法有两种：使用cookie保存、使用JWT保存。</p>
<p>但如果系统中使用了Redis缓存，那么还可以有第三种解决方案–<strong>将用户token缓存在Redis中</strong>。</p>
<p>header里面放Authorization，就是为了验证用户身份，现在前后端分离，有跨域问题，session经常会失效</p>
<p><strong>什么是跨域？</strong><br>浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域</p>
<p>比如说，前端域名是<a target="_blank" rel="noopener" href="http://www.abc.com,那么在当前环境中运行的js代码,出于安全考虑,访问www.xyz.com域名下的资源,是受到限制的.现代浏览器默认都会基于安全原因而阻止跨域的ajax请求,这是现代浏览器中必备的功能,但是往往给开发带来不便./">www.abc.com，那么在当前环境中运行的js代码，出于安全考虑，访问www.xyz.com域名下的资源，是受到限制的。现代浏览器默认都会基于安全原因而阻止跨域的ajax请求，这是现代浏览器中必备的功能，但是往往给开发带来不便。</a></p>
<p>@component是spring中的一个注解，它的作用就是实现bean的注入，在探究@component前先了解一下注解？何为注解？注解本质上就是一个类，开发中我们可以使用注解 取代 xml配置文件。</p>
<h4 id="Spring-Configuration-注解介绍"><a href="#Spring-Configuration-注解介绍" class="headerlink" title="Spring @Configuration 注解介绍"></a>Spring @Configuration 注解介绍</h4><p>指示一个类声明<strong>一个或多个@Bean方法</strong>，并且可以由Spring容器处理</p>
<p>以便在运行时为这些bean生成<strong>BeanDefinition</strong>和服务请求</p>
<p>可以看到这个 <strong><code>@Component</code> 注解</strong>, 意味也将会注册为bean,其内部也可以依赖注入。</p>
<hr>
<p><strong>Ps:什么是依赖注入。</strong></p>
<p>Class A依赖Class B的对象b，一般情况下，需要在A代码中显式的new一个B的对象，</p>
<p>采用<strong>依赖注入</strong>技术之后，A的代码只需要定义一个私有的B对象，啥意思</p>
<p>不需要直接new来获得这个对象，</p>
<p>而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类的引用中。</p>
<p>COntroller需要service的服务，要在controller中注入service</p>
<p>private Service service;</p>
<p>同样的，service中需要注入Repository</p>
<hr>
<p>为什么注入Service，不是注入Impl？</p>
<p>就是先画个虎头，身体没画，虎身自己慢慢画</p>
<p>解耦，测试方便，<strong>面向接口编程</strong>，代理方式不同</p>
<p>ps：面向接口编程有什么好处</p>
<p><strong>面向接口编程</strong></p>
<p><strong>高内聚低耦合</strong></p>
<p><strong>设计模式之开闭原则</strong></p>
<p><strong>接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。</strong></p>
<p>—-&lt; 前面就是接口的部分，后面自己延伸。好像不太准确，这应该是继承的关系</p>
<p><strong>面向接口编程和面向对象编程是什么关系</strong> </p>
<p><strong>接口就是标准规范，就是定死了一个框架，你根据这个框架去执行！</strong></p>
<p>有了标准去遵守就容易扩展，我们只需要面向标准编程，而不用针对具体的实现类。</p>
<p>就像是只有骨架，而肉身由自己定义。</p>
<hr>
<p>@Configuration也附带了@Component的功能。所以理论上也可以使用<code>@Autowared</code>功能。上述代码可以改成下面形式</p>
<h4 id="jackson库中objectMapper的使用"><a href="#jackson库中objectMapper的使用" class="headerlink" title="jackson库中objectMapper的使用"></a>jackson库中objectMapper的使用</h4><p>Jackson可以轻松的将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象</p>
<p>ObjectMapper类是<strong>Jackson库</strong>的主要类。</p>
<h4 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h4><p>它称为ObjectMapper的原因是因为它将<strong>JSON映射到Java对象</strong>（反序列化），或将<strong>Java对象映射到JSON</strong>（序列化）。</p>
<h4 id="Jackson-ObjectMapper如何将JSON字段与Java字段匹配"><a href="#Jackson-ObjectMapper如何将JSON字段与Java字段匹配" class="headerlink" title="Jackson ObjectMapper如何将JSON字段与Java字段匹配"></a>Jackson ObjectMapper如何将JSON字段与Java字段匹配</h4><p>三种方式</p>
<ol>
<li>Jackson通过将<strong>JSON字段的名称</strong>与Java对象中的<strong>getter</strong>和<strong>setter方法</strong>相匹配，将JSON对象的字段映射到Java对象中的字段。Jackson删除了getter和setter方法名称的<strong>“get”和“set”</strong>部分，并将剩余名称的第一个字符转换为小写。</li>
<li>Jackson还可以通过java反射进行匹配</li>
<li>通过注解或者其它方式进行自定义的序列化和反序列化程序。</li>
</ol>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = ''; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://example.com/2021/09/02/9%E6%9C%882%E6%97%A5/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://example.com/2021/09/02/9%E6%9C%882%E6%97%A5/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://baidu.com " style="border-bottom: none;">wzr1005</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
